generator client {
  provider = "prisma-client-js"
}

generator erd {
  provider = "prisma-erd-generator"
  output   = "../erd/ERD.svg"
  theme    = "forest"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model file {
  id         String   @id @default(uuid())
  bucket     String
  name       String
  createdAt  DateTime @default(now())
  updated_at DateTime @updatedAt
  type       String
  size       Int

  avatar_file_users user[] @relation("user_avatar_file", map: "user_avatar_file")
  banner_file_users user[] @relation("user_banner_file", map: "user_banner_file")
  avatar_file_clubs club[] @relation("club_avatar_file", map: "club_avatar_file")
  banner_file_clubs club[] @relation("club_banner_file", map: "club_banner_file")
}

model user {
  id                    String                       @id @unique
  username              String                       @unique
  email                 String                       @unique
  email_verified        Boolean                      @default(false)
  hashed_password       String
  created_at            DateTime                     @default(now())
  updated_at            DateTime                     @updatedAt
  stripe_id             String?                      @unique
  role                  UserRole                     @default(BASE) // subscription type
  bike_ftp              Int                          @default(0) // watts
  run_ftp               Int                          @default(0) // m/s 
  swim_ftp              Int                          @default(0) // m/s 
  unit_type             UnitType                     @default(METRIC) // controls user display
  max_hr                Int                          @default(0) // 0-240
  private               Boolean                      @default(true)
  activities            activities[]
  email_tokens          emailVerificationToken[]
  keys                  key[]
  password_tokens       passwordResetToken[]
  auth_sessions         session[]
  subscription          subscription?
  integration_logs      thirdPartyIntegrationLogs[]
  integrations          thirdPartyIntegrationToken[]
  training_sessions     trainingSession[]
  requested_friendships Friendship[]                 @relation("requester_friendship")
  addressed_friendships Friendship[]                 @relation("addressee_friendship")
  LikedTrainingSession  likedTrainingSession[]
  club_memberships      club_member[]
  avatar_file           file?                        @relation("user_avatar_file", fields: [avatar_file_id], onDelete: Cascade, references: [id])
  avatar_file_id        String?
  banner_file           file?                        @relation("user_banner_file", fields: [banner_file_id], onDelete: Cascade, references: [id])
  banner_file_id        String?

  @@index([id])
}

model subscription {
  user_id              String    @id @unique
  cancel_at            DateTime?
  cancel_at_period_end Boolean?
  canceled_at          DateTime?
  current_period_start DateTime
  current_period_end   DateTime
  created_at           DateTime  @default(now())
  ended_at             DateTime?
  start_date           DateTime
  trial_start          DateTime?
  trial_end            DateTime?
  metadata             Json
  status               String
  stripe_sub_id        String    @unique
  user                 user      @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "subscription_user_id_user_id_fk")

  @@index([user_id])
}

model Friendship {
  requester_id String
  addressee_id String
  status       FriendshipStatus
  created_at   DateTime         @default(now())
  updated_at   DateTime         @updatedAt
  requester    user             @relation("requester_friendship", fields: [requester_id], references: [id])
  addressee    user             @relation("addressee_friendship", fields: [addressee_id], references: [id])

  @@id(name: "friendship_id", [requester_id, addressee_id])
  @@unique([requester_id, addressee_id])
}

model club {
  id             Int           @id @default(autoincrement())
  name           String
  description    String
  created_at     DateTime      @default(now())
  updated_at     DateTime      @updatedAt
  members        club_member[]
  club_event     club_event[]
  avatar_file    file?         @relation("club_avatar_file", onDelete: Cascade, fields: [avatar_file_id], references: [id])
  avatar_file_id String?
  banner_file    file?         @relation("club_banner_file", onDelete: Cascade, fields: [banner_file_id], references: [id])
  banner_file_id String?
  private        Boolean       @default(false)
}

model club_member {
  user_id    String
  club_id    Int
  status     FriendshipStatus
  admin      Boolean          @default(false)
  created_at DateTime         @default(now())
  updated_at DateTime         @updatedAt

  club club @relation(fields: [club_id], references: [id], onDelete: Cascade, map: "club_member_club_id_club_id_fk")
  user user @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "club_member_user_id_user_id_fk")

  @@id(name: "club_member_id", [user_id, club_id])
  @@unique([user_id, club_id])
}

model club_event {
  id                  Int              @id @default(autoincrement())
  club_id             Int
  date                DateTime
  name                String
  description         String
  training_session_id Int?
  training_session    trainingSession? @relation(fields: [training_session_id], references: [id], map: "club_event_training_session_id_fk")
  club                club             @relation(fields: [club_id], references: [id], onDelete: Cascade, map: "club_event_club_id_club_id_fk")
  recurrence_id       String?
}

model session {
  id        String   @id @unique
  userId    String
  expiresAt DateTime
  user      user     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "session_user_id_user_id_fk")
}

model key {
  id              String  @id @unique
  hashed_password String?
  user_id         String
  user            user    @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "key_user_id_user_id_fk")
}

model passwordResetToken {
  id          Int      @id @default(autoincrement())
  hashed_code String   @unique
  expires_at  DateTime
  user_id     String
  user        user     @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "passwordResetToken_user_id_user_id_fk")
}

model emailVerificationToken {
  id         Int      @id @default(autoincrement())
  code       String
  expires_at DateTime
  user_id    String
  user       user     @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "emailVerificationToken_user_id_user_id_fk")
}

model thirdPartyIntegrationToken {
  id             Int                           @id @default(autoincrement())
  user_id        String
  provider       ThirdPartyIntegrationProvider
  expires_at     DateTime
  created_at     DateTime                      @default(now())
  updated_at     DateTime                      @updatedAt
  access_token   String
  refresh_token  String
  integration_id String                        @unique
  logs           thirdPartyIntegrationLogs[]
  user           user                          @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "thirdPartyIntegrationToken_user_id_user_id_fk")
}

model thirdPartyIntegrationLogs {
  id         Int                           @id @default(autoincrement())
  provider   ThirdPartyIntegrationProvider
  created_at DateTime                      @default(now())
  updated_at DateTime                      @updatedAt
  metadata   Json
  user_id    String
  token_id   Int
  activity   activities?
  token      thirdPartyIntegrationToken    @relation(fields: [token_id], references: [id], onDelete: Cascade, map: "thirdPartyIntegrationLogs_token_id_thirdPartyIntegrationToken_i")
  user       user                          @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "thirdPartyIntegrationLogs_user_id_user_id_fk")
}

model activities {
  id                     Int                        @id @unique @default(autoincrement())
  type                   ActivityType
  distance               Float
  duration               Int
  date                   DateTime                   @default(now())
  user_id                String
  stress_score           Float
  thirdparty_log_id      Int?                       @unique
  intensity_factor_score Float
  log                    thirdPartyIntegrationLogs? @relation(fields: [thirdparty_log_id], references: [id], map: "activities_thirdparty_log_id_thirdPartyIntegrationLogs_id_fk")
  user                   user                       @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "activities_user_id_user_id_fk")
}

model trainingSession {
  id                   Int                    @id @default(autoincrement())
  title                String
  activity_type        ActivityType
  description          String?
  distance             Int?
  duration             Int
  stress_score         Float
  plan                 Json[]                 @default([])
  user_id              String
  user                 user                   @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "trainingPlan_user_id_user_id_fk")
  likedTrainingSession likedTrainingSession[]
  club_event           club_event[]
}

model likedTrainingSession {
  user_id             String
  training_session_id Int
  timestamp           DateTime        @default(now())
  user                user            @relation(fields: [user_id], references: [id], onDelete: Cascade, map: "liked_training_session_user_id_user_id_fk")
  training_session    trainingSession @relation(fields: [training_session_id], references: [id], onDelete: Cascade, map: "liked_training_session_ts_id_ts_id_fk")

  @@id([user_id, training_session_id])
  @@unique([user_id, training_session_id])
  @@index([user_id])
  @@index([training_session_id])
}

enum ActivityType {
  SWIM
  BIKE
  RUN
}

enum UserRole {
  PRO
  BASE
  TRIAL
}

enum ThirdPartyIntegrationProvider {
  STRAVA
  WAHOO
}

enum UnitType {
  IMPERIAL
  METRIC
}

enum FriendshipStatus {
  REQUESTED
  ACCEPTED
  BLOCKED
  DECLINED
}
