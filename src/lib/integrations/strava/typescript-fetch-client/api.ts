/* eslint-disable */
//@ts-nocheck
// tslint:disable
/**
 * Strava API v3
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write unknown client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

const BASE_PATH = 'https://www.strava.com/api/v3'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ',',
	ssv: ' ',
	tsv: '\t',
	pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
	(url: string, init?: unknown): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: unknown;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration?: Configuration;

	constructor(
		configuration?: Configuration,
		protected basePath: string = BASE_PATH,
		protected fetch: FetchAPI = portableFetch
	) {
		if (configuration) {
			this.configuration = configuration;
			this.basePath = configuration.basePath || this.basePath;
		}
	}
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name = 'RequiredError';
	constructor(
		public field: string,
		msg?: string
	) {
		super(msg);
	}
}

/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Creates a manual activity for an athlete, requires activity:write scope.
		 * @summary Create an Activity
		 * @param {string} name The name of the activity.
		 * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
		 * @param {Date} start_date_local ISO 8601 formatted date time.
		 * @param {number} elapsedTime In seconds.
		 * @param {string} [type] Type of activity. For example - Run, Ride etc.
		 * @param {string} [description] Description of the activity.
		 * @param {number} [distance] In meters.
		 * @param {number} [trainer] Set to 1 to mark as a trainer activity.
		 * @param {number} [commute] Set to 1 to mark as commute.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createActivity(
			name: string,
			sportType: string,
			start_date_local: Date,
			elapsedTime: number,
			type?: string,
			description?: string,
			distance?: number,
			trainer?: number,
			commute?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'name' is not null or undefined
			if (name === null || name === undefined) {
				throw new RequiredError(
					'name',
					'Required parameter name was null or undefined when calling createActivity.'
				);
			}
			// verify required parameter 'sportType' is not null or undefined
			if (sportType === null || sportType === undefined) {
				throw new RequiredError(
					'sportType',
					'Required parameter sportType was null or undefined when calling createActivity.'
				);
			}
			// verify required parameter 'start_date_local' is not null or undefined
			if (start_date_local === null || start_date_local === undefined) {
				throw new RequiredError(
					'start_date_local',
					'Required parameter start_date_local was null or undefined when calling createActivity.'
				);
			}
			// verify required parameter 'elapsedTime' is not null or undefined
			if (elapsedTime === null || elapsedTime === undefined) {
				throw new RequiredError(
					'elapsedTime',
					'Required parameter elapsedTime was null or undefined when calling createActivity.'
				);
			}
			const localVarPath = `/activities`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;
			const localVarFormParams = new url.URLSearchParams();

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (name !== undefined) {
				localVarFormParams.set('name', name as unknown);
			}

			if (type !== undefined) {
				localVarFormParams.set('type', type as unknown);
			}

			if (sportType !== undefined) {
				localVarFormParams.set('sport_type', sportType as unknown);
			}

			if (start_date_local !== undefined) {
				localVarFormParams.set('start_date_local', start_date_local as unknown);
			}

			if (elapsedTime !== undefined) {
				localVarFormParams.set('elapsed_time', elapsedTime as unknown);
			}

			if (description !== undefined) {
				localVarFormParams.set('description', description as unknown);
			}

			if (distance !== undefined) {
				localVarFormParams.set('distance', distance as unknown);
			}

			if (trainer !== undefined) {
				localVarFormParams.set('trainer', trainer as unknown);
			}

			if (commute !== undefined) {
				localVarFormParams.set('commute', commute as unknown);
			}

			localVarHeaderParameter['Content-Type'] =
				'application/x-www-form-urlencoded';

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);
			localVarRequestOptions.body = localVarFormParams.toString();

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity
		 * @param {number} id The identifier of the activity.
		 * @param {boolean} [includeAllEfforts] To include all segments efforts.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityById(
			id: number,
			includeAllEfforts?: boolean,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getActivityById.'
				);
			}
			const localVarPath = `/activities/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (includeAllEfforts !== undefined) {
				localVarQueryParameter['include_all_efforts'] = includeAllEfforts;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Comments
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Deprecated. Prefer to use after_cursor.
		 * @param {number} [perPage] Deprecated. Prefer to use page_size.
		 * @param {number} [pageSize] Number of items per page. Defaults to 30.
		 * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCommentsByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			pageSize?: number,
			afterCursor?: string,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getCommentsByActivityId.'
				);
			}
			const localVarPath = `/activities/{id}/comments`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			if (pageSize !== undefined) {
				localVarQueryParameter['page_size'] = pageSize;
			}

			if (afterCursor !== undefined) {
				localVarQueryParameter['after_cursor'] = afterCursor;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Kudoers
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getKudoersByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getKudoersByActivityId.'
				);
			}
			const localVarPath = `/activities/{id}/kudos`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Laps
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLapsByActivityId(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getLapsByActivityId.'
				);
			}
			const localVarPath = `/activities/{id}/laps`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
		 * @summary List Athlete Activities
		 * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
		 * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteActivities(
			before?: number,
			after?: number,
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			const localVarPath = `/athlete/activities`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (before !== undefined) {
				localVarQueryParameter['before'] = before;
			}

			if (after !== undefined) {
				localVarQueryParameter['after'] = after;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity Zones
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getZonesByActivityId(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getZonesByActivityId.'
				);
			}
			const localVarPath = `/activities/{id}/zones`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
		 * @summary Update Activity
		 * @param {number} id The identifier of the activity.
		 * @param {UpdatableActivity} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateActivityById(
			id: number,
			body?: UpdatableActivity,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling updateActivityById.'
				);
			}
			const localVarPath = `/activities/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarHeaderParameter['Content-Type'] = 'application/json';

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);
			const needsSerialization =
				<unknown>'UpdatableActivity' !== 'string' ||
				localVarRequestOptions.headers['Content-Type'] === 'application/json';
			localVarRequestOptions.body = needsSerialization
				? JSON.stringify(body || {})
				: body || '';

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Creates a manual activity for an athlete, requires activity:write scope.
		 * @summary Create an Activity
		 * @param {string} name The name of the activity.
		 * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
		 * @param {Date} start_date_local ISO 8601 formatted date time.
		 * @param {number} elapsedTime In seconds.
		 * @param {string} [type] Type of activity. For example - Run, Ride etc.
		 * @param {string} [description] Description of the activity.
		 * @param {number} [distance] In meters.
		 * @param {number} [trainer] Set to 1 to mark as a trainer activity.
		 * @param {number} [commute] Set to 1 to mark as commute.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createActivity(
			name: string,
			sportType: string,
			start_date_local: Date,
			elapsedTime: number,
			type?: string,
			description?: string,
			distance?: number,
			trainer?: number,
			commute?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).createActivity(
				name,
				sportType,
				start_date_local,
				elapsedTime,
				type,
				description,
				distance,
				trainer,
				commute,
				options
			);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity
		 * @param {number} id The identifier of the activity.
		 * @param {boolean} [includeAllEfforts] To include all segments efforts.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityById(
			id: number,
			includeAllEfforts?: boolean,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getActivityById(id, includeAllEfforts, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Comments
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Deprecated. Prefer to use after_cursor.
		 * @param {number} [perPage] Deprecated. Prefer to use page_size.
		 * @param {number} [pageSize] Number of items per page. Defaults to 30.
		 * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCommentsByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			pageSize?: number,
			afterCursor?: string,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Comment>> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getCommentsByActivityId(
				id,
				page,
				perPage,
				pageSize,
				afterCursor,
				options
			);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Kudoers
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getKudoersByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getKudoersByActivityId(id, page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Laps
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLapsByActivityId(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Lap>> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getLapsByActivityId(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
		 * @summary List Athlete Activities
		 * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
		 * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteActivities(
			before?: number,
			after?: number,
			page?: number,
			perPage?: number,
			options?: unknown
		): (
			fetch?: FetchAPI,
			basePath?: string
		) => Promise<Array<SummaryActivity>> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getLoggedInAthleteActivities(before, after, page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity Zones
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getZonesByActivityId(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityZone>> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).getZonesByActivityId(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
		 * @summary Update Activity
		 * @param {number} id The identifier of the activity.
		 * @param {UpdatableActivity} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateActivityById(
			id: number,
			body?: UpdatableActivity,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
			const localVarFetchArgs = ActivitiesApiFetchParamCreator(
				configuration
			).updateActivityById(id, body, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Creates a manual activity for an athlete, requires activity:write scope.
		 * @summary Create an Activity
		 * @param {string} name The name of the activity.
		 * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
		 * @param {Date} start_date_local ISO 8601 formatted date time.
		 * @param {number} elapsedTime In seconds.
		 * @param {string} [type] Type of activity. For example - Run, Ride etc.
		 * @param {string} [description] Description of the activity.
		 * @param {number} [distance] In meters.
		 * @param {number} [trainer] Set to 1 to mark as a trainer activity.
		 * @param {number} [commute] Set to 1 to mark as commute.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createActivity(
			name: string,
			sportType: string,
			start_date_local: Date,
			elapsedTime: number,
			type?: string,
			description?: string,
			distance?: number,
			trainer?: number,
			commute?: number,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).createActivity(
				name,
				sportType,
				start_date_local,
				elapsedTime,
				type,
				description,
				distance,
				trainer,
				commute,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity
		 * @param {number} id The identifier of the activity.
		 * @param {boolean} [includeAllEfforts] To include all segments efforts.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityById(
			id: number,
			includeAllEfforts?: boolean,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).getActivityById(
				id,
				includeAllEfforts,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Comments
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Deprecated. Prefer to use after_cursor.
		 * @param {number} [perPage] Deprecated. Prefer to use page_size.
		 * @param {number} [pageSize] Number of items per page. Defaults to 30.
		 * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCommentsByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			pageSize?: number,
			afterCursor?: string,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).getCommentsByActivityId(
				id,
				page,
				perPage,
				pageSize,
				afterCursor,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Kudoers
		 * @param {number} id The identifier of the activity.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getKudoersByActivityId(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).getKudoersByActivityId(
				id,
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary List Activity Laps
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLapsByActivityId(id: number, options?: unknown) {
			return ActivitiesApiFp(configuration).getLapsByActivityId(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
		 * @summary List Athlete Activities
		 * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
		 * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteActivities(
			before?: number,
			after?: number,
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).getLoggedInAthleteActivities(
				before,
				after,
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
		 * @summary Get Activity Zones
		 * @param {number} id The identifier of the activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getZonesByActivityId(id: number, options?: unknown) {
			return ActivitiesApiFp(configuration).getZonesByActivityId(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
		 * @summary Update Activity
		 * @param {number} id The identifier of the activity.
		 * @param {UpdatableActivity} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateActivityById(
			id: number,
			body?: UpdatableActivity,
			options?: unknown
		) {
			return ActivitiesApiFp(configuration).updateActivityById(
				id,
				body,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
	/**
	 * Creates a manual activity for an athlete, requires activity:write scope.
	 * @summary Create an Activity
	 * @param {string} name The name of the activity.
	 * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
	 * @param {Date} start_date_local ISO 8601 formatted date time.
	 * @param {number} elapsedTime In seconds.
	 * @param {string} [type] Type of activity. For example - Run, Ride etc.
	 * @param {string} [description] Description of the activity.
	 * @param {number} [distance] In meters.
	 * @param {number} [trainer] Set to 1 to mark as a trainer activity.
	 * @param {number} [commute] Set to 1 to mark as commute.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public createActivity(
		name: string,
		sportType: string,
		start_date_local: Date,
		elapsedTime: number,
		type?: string,
		description?: string,
		distance?: number,
		trainer?: number,
		commute?: number,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).createActivity(
			name,
			sportType,
			start_date_local,
			elapsedTime,
			type,
			description,
			distance,
			trainer,
			commute,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
	 * @summary Get Activity
	 * @param {number} id The identifier of the activity.
	 * @param {boolean} [includeAllEfforts] To include all segments efforts.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getActivityById(
		id: number,
		includeAllEfforts?: boolean,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).getActivityById(
			id,
			includeAllEfforts,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
	 * @summary List Activity Comments
	 * @param {number} id The identifier of the activity.
	 * @param {number} [page] Deprecated. Prefer to use after_cursor.
	 * @param {number} [perPage] Deprecated. Prefer to use page_size.
	 * @param {number} [pageSize] Number of items per page. Defaults to 30.
	 * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getCommentsByActivityId(
		id: number,
		page?: number,
		perPage?: number,
		pageSize?: number,
		afterCursor?: string,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).getCommentsByActivityId(
			id,
			page,
			perPage,
			pageSize,
			afterCursor,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
	 * @summary List Activity Kudoers
	 * @param {number} id The identifier of the activity.
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getKudoersByActivityId(
		id: number,
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).getKudoersByActivityId(
			id,
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
	 * @summary List Activity Laps
	 * @param {number} id The identifier of the activity.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getLapsByActivityId(id: number, options?: unknown) {
		return ActivitiesApiFp(this.configuration).getLapsByActivityId(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
	 * @summary List Athlete Activities
	 * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
	 * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getLoggedInAthleteActivities(
		before?: number,
		after?: number,
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).getLoggedInAthleteActivities(
			before,
			after,
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
	 * @summary Get Activity Zones
	 * @param {number} id The identifier of the activity.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public getZonesByActivityId(id: number, options?: unknown) {
		return ActivitiesApiFp(this.configuration).getZonesByActivityId(
			id,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
	 * @summary Update Activity
	 * @param {number} id The identifier of the activity.
	 * @param {UpdatableActivity} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ActivitiesApi
	 */
	public updateActivityById(
		id: number,
		body?: UpdatableActivity,
		options?: unknown
	) {
		return ActivitiesApiFp(this.configuration).updateActivityById(
			id,
			body,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * AthletesApi - fetch parameter creator
 * @export
 */
export const AthletesApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
		 * @summary Get Authenticated Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthlete(options: unknown = {}): FetchArgs {
			const localVarPath = `/athlete`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
		 * @summary Get Zones
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteZones(options: unknown = {}): FetchArgs {
			const localVarPath = `/athlete/zones`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
		 * @summary Get Athlete Stats
		 * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getStats(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getStats.'
				);
			}
			const localVarPath = `/athletes/{id}/stats`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Update the currently authenticated athlete. Requires profile:write scope.
		 * @summary Update Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateLoggedInAthlete(options: unknown = {}): FetchArgs {
			const localVarPath = `/athlete`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * AthletesApi - functional programming interface
 * @export
 */
export const AthletesApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
		 * @summary Get Authenticated Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthlete(
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
			const localVarFetchArgs =
				AthletesApiFetchParamCreator(configuration).getLoggedInAthlete(options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
		 * @summary Get Zones
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteZones(
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Zones> {
			const localVarFetchArgs =
				AthletesApiFetchParamCreator(configuration).getLoggedInAthleteZones(
					options
				);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
		 * @summary Get Athlete Stats
		 * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getStats(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityStats> {
			const localVarFetchArgs = AthletesApiFetchParamCreator(
				configuration
			).getStats(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Update the currently authenticated athlete. Requires profile:write scope.
		 * @summary Update Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateLoggedInAthlete(
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
			const localVarFetchArgs =
				AthletesApiFetchParamCreator(configuration).updateLoggedInAthlete(
					options
				);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * AthletesApi - factory interface
 * @export
 */
export const AthletesApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
		 * @summary Get Authenticated Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthlete(options?: unknown) {
			return AthletesApiFp(configuration).getLoggedInAthlete(options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
		 * @summary Get Zones
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteZones(options?: unknown) {
			return AthletesApiFp(configuration).getLoggedInAthleteZones(options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
		 * @summary Get Athlete Stats
		 * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getStats(id: number, options?: unknown) {
			return AthletesApiFp(configuration).getStats(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Update the currently authenticated athlete. Requires profile:write scope.
		 * @summary Update Athlete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateLoggedInAthlete(options?: unknown) {
			return AthletesApiFp(configuration).updateLoggedInAthlete(options)(
				fetch,
				basePath
			);
		}
	};
};

/**
 * AthletesApi - object-oriented interface
 * @export
 * @class AthletesApi
 * @extends {BaseAPI}
 */
export class AthletesApi extends BaseAPI {
	/**
	 * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
	 * @summary Get Authenticated Athlete
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AthletesApi
	 */
	public getLoggedInAthlete(options?: unknown) {
		return AthletesApiFp(this.configuration).getLoggedInAthlete(options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
	 * @summary Get Zones
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AthletesApi
	 */
	public getLoggedInAthleteZones(options?: unknown) {
		return AthletesApiFp(this.configuration).getLoggedInAthleteZones(options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
	 * @summary Get Athlete Stats
	 * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AthletesApi
	 */
	public getStats(id: number, options?: unknown) {
		return AthletesApiFp(this.configuration).getStats(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Update the currently authenticated athlete. Requires profile:write scope.
	 * @summary Update Athlete
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AthletesApi
	 */
	public updateLoggedInAthlete(options?: unknown) {
		return AthletesApiFp(this.configuration).updateLoggedInAthlete(options)(
			this.fetch,
			this.basePath
		);
	}
}

/**
 * ClubsApi - fetch parameter creator
 * @export
 */
export const ClubsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
		 * @summary List Club Activities
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubActivitiesById(
			id: number,
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getClubActivitiesById.'
				);
			}
			const localVarPath = `/clubs/{id}/activities`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a list of the administrators of a given club.
		 * @summary List Club Administrators
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubAdminsById(
			id: number,
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getClubAdminsById.'
				);
			}
			const localVarPath = `/clubs/{id}/admins`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a given club using its identifier.
		 * @summary Get Club
		 * @param {number} id The identifier of the club.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubById(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getClubById.'
				);
			}
			const localVarPath = `/clubs/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a list of the athletes who are members of a given club.
		 * @summary List Club Members
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubMembersById(
			id: number,
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getClubMembersById.'
				);
			}
			const localVarPath = `/clubs/{id}/members`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a list of the clubs whose membership includes the authenticated athlete.
		 * @summary List Athlete Clubs
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteClubs(
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			const localVarPath = `/athlete/clubs`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
		 * @summary List Club Activities
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubActivitiesById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubActivity>> {
			const localVarFetchArgs = ClubsApiFetchParamCreator(
				configuration
			).getClubActivitiesById(id, page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a list of the administrators of a given club.
		 * @summary List Club Administrators
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubAdminsById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
			const localVarFetchArgs = ClubsApiFetchParamCreator(
				configuration
			).getClubAdminsById(id, page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a given club using its identifier.
		 * @summary Get Club
		 * @param {number} id The identifier of the club.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubById(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedClub> {
			const localVarFetchArgs = ClubsApiFetchParamCreator(
				configuration
			).getClubById(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a list of the athletes who are members of a given club.
		 * @summary List Club Members
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubMembersById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubAthlete>> {
			const localVarFetchArgs = ClubsApiFetchParamCreator(
				configuration
			).getClubMembersById(id, page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a list of the clubs whose membership includes the authenticated athlete.
		 * @summary List Athlete Clubs
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteClubs(
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryClub>> {
			const localVarFetchArgs = ClubsApiFetchParamCreator(
				configuration
			).getLoggedInAthleteClubs(page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
		 * @summary List Club Activities
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubActivitiesById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ClubsApiFp(configuration).getClubActivitiesById(
				id,
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns a list of the administrators of a given club.
		 * @summary List Club Administrators
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubAdminsById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ClubsApiFp(configuration).getClubAdminsById(
				id,
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns a given club using its identifier.
		 * @summary Get Club
		 * @param {number} id The identifier of the club.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubById(id: number, options?: unknown) {
			return ClubsApiFp(configuration).getClubById(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns a list of the athletes who are members of a given club.
		 * @summary List Club Members
		 * @param {number} id The identifier of the club.
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getClubMembersById(
			id: number,
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ClubsApiFp(configuration).getClubMembersById(
				id,
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns a list of the clubs whose membership includes the authenticated athlete.
		 * @summary List Athlete Clubs
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteClubs(
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return ClubsApiFp(configuration).getLoggedInAthleteClubs(
				page,
				perPage,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
	/**
	 * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
	 * @summary List Club Activities
	 * @param {number} id The identifier of the club.
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClubsApi
	 */
	public getClubActivitiesById(
		id: number,
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ClubsApiFp(this.configuration).getClubActivitiesById(
			id,
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns a list of the administrators of a given club.
	 * @summary List Club Administrators
	 * @param {number} id The identifier of the club.
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClubsApi
	 */
	public getClubAdminsById(
		id: number,
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ClubsApiFp(this.configuration).getClubAdminsById(
			id,
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns a given club using its identifier.
	 * @summary Get Club
	 * @param {number} id The identifier of the club.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClubsApi
	 */
	public getClubById(id: number, options?: unknown) {
		return ClubsApiFp(this.configuration).getClubById(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns a list of the athletes who are members of a given club.
	 * @summary List Club Members
	 * @param {number} id The identifier of the club.
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClubsApi
	 */
	public getClubMembersById(
		id: number,
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ClubsApiFp(this.configuration).getClubMembersById(
			id,
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns a list of the clubs whose membership includes the authenticated athlete.
	 * @summary List Athlete Clubs
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClubsApi
	 */
	public getLoggedInAthleteClubs(
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return ClubsApiFp(this.configuration).getLoggedInAthleteClubs(
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * GearsApi - fetch parameter creator
 * @export
 */
export const GearsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns an equipment using its identifier.
		 * @summary Get Equipment
		 * @param {string} id The identifier of the gear.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getGearById(id: string, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getGearById.'
				);
			}
			const localVarPath = `/gear/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * GearsApi - functional programming interface
 * @export
 */
export const GearsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns an equipment using its identifier.
		 * @summary Get Equipment
		 * @param {string} id The identifier of the gear.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getGearById(
			id: string,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedGear> {
			const localVarFetchArgs = GearsApiFetchParamCreator(
				configuration
			).getGearById(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * GearsApi - factory interface
 * @export
 */
export const GearsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns an equipment using its identifier.
		 * @summary Get Equipment
		 * @param {string} id The identifier of the gear.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getGearById(id: string, options?: unknown) {
			return GearsApiFp(configuration).getGearById(id, options)(
				fetch,
				basePath
			);
		}
	};
};

/**
 * GearsApi - object-oriented interface
 * @export
 * @class GearsApi
 * @extends {BaseAPI}
 */
export class GearsApi extends BaseAPI {
	/**
	 * Returns an equipment using its identifier.
	 * @summary Get Equipment
	 * @param {string} id The identifier of the gear.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof GearsApi
	 */
	public getGearById(id: string, options?: unknown) {
		return GearsApiFp(this.configuration).getGearById(id, options)(
			this.fetch,
			this.basePath
		);
	}
}

/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns a GPX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route GPX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsGPX(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getRouteAsGPX.'
				);
			}
			const localVarPath = `/routes/{id}/export_gpx`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a TCX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route TCX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsTCX(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getRouteAsTCX.'
				);
			}
			const localVarPath = `/routes/{id}/export_tcx`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a route using its identifier. Requires read_all scope for private routes.
		 * @summary Get Route
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteById(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getRouteById.'
				);
			}
			const localVarPath = `/routes/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
		 * @summary List Athlete Routes
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRoutesByAthleteId(
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			const localVarPath = `/athletes/{id}/routes`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns a GPX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route GPX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsGPX(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = RoutesApiFetchParamCreator(
				configuration
			).getRouteAsGPX(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response;
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a TCX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route TCX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsTCX(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = RoutesApiFetchParamCreator(
				configuration
			).getRouteAsTCX(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response;
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a route using its identifier. Requires read_all scope for private routes.
		 * @summary Get Route
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteById(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Route> {
			const localVarFetchArgs = RoutesApiFetchParamCreator(
				configuration
			).getRouteById(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
		 * @summary List Athlete Routes
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRoutesByAthleteId(
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Route>> {
			const localVarFetchArgs = RoutesApiFetchParamCreator(
				configuration
			).getRoutesByAthleteId(page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns a GPX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route GPX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsGPX(id: number, options?: unknown) {
			return RoutesApiFp(configuration).getRouteAsGPX(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns a TCX file of the route. Requires read_all scope for private routes.
		 * @summary Export Route TCX
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteAsTCX(id: number, options?: unknown) {
			return RoutesApiFp(configuration).getRouteAsTCX(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns a route using its identifier. Requires read_all scope for private routes.
		 * @summary Get Route
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteById(id: number, options?: unknown) {
			return RoutesApiFp(configuration).getRouteById(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
		 * @summary List Athlete Routes
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRoutesByAthleteId(page?: number, perPage?: number, options?: unknown) {
			return RoutesApiFp(configuration).getRoutesByAthleteId(
				page,
				perPage,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
	/**
	 * Returns a GPX file of the route. Requires read_all scope for private routes.
	 * @summary Export Route GPX
	 * @param {number} id The identifier of the route.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoutesApi
	 */
	public getRouteAsGPX(id: number, options?: unknown) {
		return RoutesApiFp(this.configuration).getRouteAsGPX(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns a TCX file of the route. Requires read_all scope for private routes.
	 * @summary Export Route TCX
	 * @param {number} id The identifier of the route.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoutesApi
	 */
	public getRouteAsTCX(id: number, options?: unknown) {
		return RoutesApiFp(this.configuration).getRouteAsTCX(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns a route using its identifier. Requires read_all scope for private routes.
	 * @summary Get Route
	 * @param {number} id The identifier of the route.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoutesApi
	 */
	public getRouteById(id: number, options?: unknown) {
		return RoutesApiFp(this.configuration).getRouteById(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
	 * @summary List Athlete Routes
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoutesApi
	 */
	public getRoutesByAthleteId(
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return RoutesApiFp(this.configuration).getRoutesByAthleteId(
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * SegmentEffortsApi - fetch parameter creator
 * @export
 */
export const SegmentEffortsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
		 * @summary List Segment Efforts
		 * @param {number} segmentId The identifier of the segment.
		 * @param {Date} [start_date_local] ISO 8601 formatted date time.
		 * @param {Date} [endDateLocal] ISO 8601 formatted date time.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEffortsBySegmentId(
			segmentId: number,
			start_date_local?: Date,
			endDateLocal?: Date,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'segmentId' is not null or undefined
			if (segmentId === null || segmentId === undefined) {
				throw new RequiredError(
					'segmentId',
					'Required parameter segmentId was null or undefined when calling getEffortsBySegmentId.'
				);
			}
			const localVarPath = `/segment_efforts`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (segmentId !== undefined) {
				localVarQueryParameter['segment_id'] = segmentId;
			}

			if (start_date_local !== undefined) {
				localVarQueryParameter['start_date_local'] = (
					start_date_local as unknown
				).toISOString();
			}

			if (endDateLocal !== undefined) {
				localVarQueryParameter['end_date_local'] = (
					endDateLocal as unknown
				).toISOString();
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
		 * @summary Get Segment Effort
		 * @param {number} id The identifier of the segment effort.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortById(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getSegmentEffortById.'
				);
			}
			const localVarPath = `/segment_efforts/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * SegmentEffortsApi - functional programming interface
 * @export
 */
export const SegmentEffortsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
		 * @summary List Segment Efforts
		 * @param {number} segmentId The identifier of the segment.
		 * @param {Date} [start_date_local] ISO 8601 formatted date time.
		 * @param {Date} [endDateLocal] ISO 8601 formatted date time.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEffortsBySegmentId(
			segmentId: number,
			start_date_local?: Date,
			endDateLocal?: Date,
			perPage?: number,
			options?: unknown
		): (
			fetch?: FetchAPI,
			basePath?: string
		) => Promise<Array<DetailedSegmentEffort>> {
			const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(
				configuration
			).getEffortsBySegmentId(
				segmentId,
				start_date_local,
				endDateLocal,
				perPage,
				options
			);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
		 * @summary Get Segment Effort
		 * @param {number} id The identifier of the segment effort.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortById(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegmentEffort> {
			const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(
				configuration
			).getSegmentEffortById(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * SegmentEffortsApi - factory interface
 * @export
 */
export const SegmentEffortsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
		 * @summary List Segment Efforts
		 * @param {number} segmentId The identifier of the segment.
		 * @param {Date} [start_date_local] ISO 8601 formatted date time.
		 * @param {Date} [endDateLocal] ISO 8601 formatted date time.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEffortsBySegmentId(
			segmentId: number,
			start_date_local?: Date,
			endDateLocal?: Date,
			perPage?: number,
			options?: unknown
		) {
			return SegmentEffortsApiFp(configuration).getEffortsBySegmentId(
				segmentId,
				start_date_local,
				endDateLocal,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
		 * @summary Get Segment Effort
		 * @param {number} id The identifier of the segment effort.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortById(id: number, options?: unknown) {
			return SegmentEffortsApiFp(configuration).getSegmentEffortById(
				id,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * SegmentEffortsApi - object-oriented interface
 * @export
 * @class SegmentEffortsApi
 * @extends {BaseAPI}
 */
export class SegmentEffortsApi extends BaseAPI {
	/**
	 * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
	 * @summary List Segment Efforts
	 * @param {number} segmentId The identifier of the segment.
	 * @param {Date} [start_date_local] ISO 8601 formatted date time.
	 * @param {Date} [endDateLocal] ISO 8601 formatted date time.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentEffortsApi
	 */
	public getEffortsBySegmentId(
		segmentId: number,
		start_date_local?: Date,
		endDateLocal?: Date,
		perPage?: number,
		options?: unknown
	) {
		return SegmentEffortsApiFp(this.configuration).getEffortsBySegmentId(
			segmentId,
			start_date_local,
			endDateLocal,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
	 * @summary Get Segment Effort
	 * @param {number} id The identifier of the segment effort.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentEffortsApi
	 */
	public getSegmentEffortById(id: number, options?: unknown) {
		return SegmentEffortsApiFp(this.configuration).getSegmentEffortById(
			id,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * SegmentsApi - fetch parameter creator
 * @export
 */
export const SegmentsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns the top 10 segments matching a specified query.
		 * @summary Explore segments
		 * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
		 * @param {'running' | 'riding'} [activityType] Desired activity type.
		 * @param {number} [minCat] The minimum climbing category.
		 * @param {number} [maxCat] The maximum climbing category.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		exploreSegments(
			bounds: Array<number>,
			activityType?: 'running' | 'riding',
			minCat?: number,
			maxCat?: number,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'bounds' is not null or undefined
			if (bounds === null || bounds === undefined) {
				throw new RequiredError(
					'bounds',
					'Required parameter bounds was null or undefined when calling exploreSegments.'
				);
			}
			const localVarPath = `/segments/explore`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (bounds) {
				localVarQueryParameter['bounds'] = bounds.join(
					COLLECTION_FORMATS['csv']
				);
			}

			if (activityType !== undefined) {
				localVarQueryParameter['activity_type'] = activityType;
			}

			if (minCat !== undefined) {
				localVarQueryParameter['min_cat'] = minCat;
			}

			if (maxCat !== undefined) {
				localVarQueryParameter['max_cat'] = maxCat;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
		 * @summary List Starred Segments
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteStarredSegments(
			page?: number,
			perPage?: number,
			options: unknown = {}
		): FetchArgs {
			const localVarPath = `/segments/starred`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page;
			}

			if (perPage !== undefined) {
				localVarQueryParameter['per_page'] = perPage;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
		 * @summary Get Segment
		 * @param {number} id The identifier of the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentById(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getSegmentById.'
				);
			}
			const localVarPath = `/segments/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
		 * @summary Star Segment
		 * @param {number} id The identifier of the segment to star.
		 * @param {boolean} starred If true, star the segment; if false, unstar the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		starSegment(
			id: number,
			starred: boolean,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling starSegment.'
				);
			}
			// verify required parameter 'starred' is not null or undefined
			if (starred === null || starred === undefined) {
				throw new RequiredError(
					'starred',
					'Required parameter starred was null or undefined when calling starSegment.'
				);
			}
			const localVarPath = `/segments/{id}/starred`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;
			const localVarFormParams = new url.URLSearchParams();

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (starred !== undefined) {
				localVarFormParams.set('starred', starred as unknown);
			}

			localVarHeaderParameter['Content-Type'] =
				'application/x-www-form-urlencoded';

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);
			localVarRequestOptions.body = localVarFormParams.toString();

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns the top 10 segments matching a specified query.
		 * @summary Explore segments
		 * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
		 * @param {'running' | 'riding'} [activityType] Desired activity type.
		 * @param {number} [minCat] The minimum climbing category.
		 * @param {number} [maxCat] The maximum climbing category.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		exploreSegments(
			bounds: Array<number>,
			activityType?: 'running' | 'riding',
			minCat?: number,
			maxCat?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<ExplorerResponse> {
			const localVarFetchArgs = SegmentsApiFetchParamCreator(
				configuration
			).exploreSegments(bounds, activityType, minCat, maxCat, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
		 * @summary List Starred Segments
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteStarredSegments(
			page?: number,
			perPage?: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummarySegment>> {
			const localVarFetchArgs = SegmentsApiFetchParamCreator(
				configuration
			).getLoggedInAthleteStarredSegments(page, perPage, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
		 * @summary Get Segment
		 * @param {number} id The identifier of the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentById(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
			const localVarFetchArgs = SegmentsApiFetchParamCreator(
				configuration
			).getSegmentById(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
		 * @summary Star Segment
		 * @param {number} id The identifier of the segment to star.
		 * @param {boolean} starred If true, star the segment; if false, unstar the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		starSegment(
			id: number,
			starred: boolean,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
			const localVarFetchArgs = SegmentsApiFetchParamCreator(
				configuration
			).starSegment(id, starred, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns the top 10 segments matching a specified query.
		 * @summary Explore segments
		 * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
		 * @param {'running' | 'riding'} [activityType] Desired activity type.
		 * @param {number} [minCat] The minimum climbing category.
		 * @param {number} [maxCat] The maximum climbing category.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		exploreSegments(
			bounds: Array<number>,
			activityType?: 'running' | 'riding',
			minCat?: number,
			maxCat?: number,
			options?: unknown
		) {
			return SegmentsApiFp(configuration).exploreSegments(
				bounds,
				activityType,
				minCat,
				maxCat,
				options
			)(fetch, basePath);
		},
		/**
		 * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
		 * @summary List Starred Segments
		 * @param {number} [page] Page number. Defaults to 1.
		 * @param {number} [perPage] Number of items per page. Defaults to 30.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLoggedInAthleteStarredSegments(
			page?: number,
			perPage?: number,
			options?: unknown
		) {
			return SegmentsApiFp(configuration).getLoggedInAthleteStarredSegments(
				page,
				perPage,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
		 * @summary Get Segment
		 * @param {number} id The identifier of the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentById(id: number, options?: unknown) {
			return SegmentsApiFp(configuration).getSegmentById(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
		 * @summary Star Segment
		 * @param {number} id The identifier of the segment to star.
		 * @param {boolean} starred If true, star the segment; if false, unstar the segment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		starSegment(id: number, starred: boolean, options?: unknown) {
			return SegmentsApiFp(configuration).starSegment(
				id,
				starred,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
	/**
	 * Returns the top 10 segments matching a specified query.
	 * @summary Explore segments
	 * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
	 * @param {'running' | 'riding'} [activityType] Desired activity type.
	 * @param {number} [minCat] The minimum climbing category.
	 * @param {number} [maxCat] The maximum climbing category.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentsApi
	 */
	public exploreSegments(
		bounds: Array<number>,
		activityType?: 'running' | 'riding',
		minCat?: number,
		maxCat?: number,
		options?: unknown
	) {
		return SegmentsApiFp(this.configuration).exploreSegments(
			bounds,
			activityType,
			minCat,
			maxCat,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
	 * @summary List Starred Segments
	 * @param {number} [page] Page number. Defaults to 1.
	 * @param {number} [perPage] Number of items per page. Defaults to 30.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentsApi
	 */
	public getLoggedInAthleteStarredSegments(
		page?: number,
		perPage?: number,
		options?: unknown
	) {
		return SegmentsApiFp(this.configuration).getLoggedInAthleteStarredSegments(
			page,
			perPage,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
	 * @summary Get Segment
	 * @param {number} id The identifier of the segment.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentsApi
	 */
	public getSegmentById(id: number, options?: unknown) {
		return SegmentsApiFp(this.configuration).getSegmentById(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
	 * @summary Star Segment
	 * @param {number} id The identifier of the segment to star.
	 * @param {boolean} starred If true, star the segment; if false, unstar the segment.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SegmentsApi
	 */
	public starSegment(id: number, starred: boolean, options?: unknown) {
		return SegmentsApiFp(this.configuration).starSegment(
			id,
			starred,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
		 * @summary Get Activity Streams
		 * @param {number} id The identifier of the activity.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getActivityStreams.'
				);
			}
			// verify required parameter 'keys' is not null or undefined
			if (keys === null || keys === undefined) {
				throw new RequiredError(
					'keys',
					'Required parameter keys was null or undefined when calling getActivityStreams.'
				);
			}
			// verify required parameter 'keyByType' is not null or undefined
			if (keyByType === null || keyByType === undefined) {
				throw new RequiredError(
					'keyByType',
					'Required parameter keyByType was null or undefined when calling getActivityStreams.'
				);
			}
			const localVarPath = `/activities/{id}/streams`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (keys) {
				localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
			}

			if (keyByType !== undefined) {
				localVarQueryParameter['key_by_type'] = keyByType;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the given route's streams. Requires read_all scope for private routes.
		 * @summary Get Route Streams
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteStreams(id: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getRouteStreams.'
				);
			}
			const localVarPath = `/routes/{id}/streams`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
		 * @summary Get Segment Effort Streams
		 * @param {number} id The identifier of the segment effort.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getSegmentEffortStreams.'
				);
			}
			// verify required parameter 'keys' is not null or undefined
			if (keys === null || keys === undefined) {
				throw new RequiredError(
					'keys',
					'Required parameter keys was null or undefined when calling getSegmentEffortStreams.'
				);
			}
			// verify required parameter 'keyByType' is not null or undefined
			if (keyByType === null || keyByType === undefined) {
				throw new RequiredError(
					'keyByType',
					'Required parameter keyByType was null or undefined when calling getSegmentEffortStreams.'
				);
			}
			const localVarPath = `/segment_efforts/{id}/streams`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (keys) {
				localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
			}

			if (keyByType !== undefined) {
				localVarQueryParameter['key_by_type'] = keyByType;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns the given segment's streams. Requires read_all scope for private segments.
		 * @summary Get Segment Streams
		 * @param {number} id The identifier of the segment.
		 * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentStreams(
			id: number,
			keys: Array<'distance' | 'latlng' | 'altitude'>,
			keyByType: boolean,
			options: unknown = {}
		): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError(
					'id',
					'Required parameter id was null or undefined when calling getSegmentStreams.'
				);
			}
			// verify required parameter 'keys' is not null or undefined
			if (keys === null || keys === undefined) {
				throw new RequiredError(
					'keys',
					'Required parameter keys was null or undefined when calling getSegmentStreams.'
				);
			}
			// verify required parameter 'keyByType' is not null or undefined
			if (keyByType === null || keyByType === undefined) {
				throw new RequiredError(
					'keyByType',
					'Required parameter keyByType was null or undefined when calling getSegmentStreams.'
				);
			}
			const localVarPath = `/segments/{id}/streams`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (keys) {
				localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
			}

			if (keyByType !== undefined) {
				localVarQueryParameter['key_by_type'] = keyByType;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
		 * @summary Get Activity Streams
		 * @param {number} id The identifier of the activity.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
			const localVarFetchArgs = StreamsApiFetchParamCreator(
				configuration
			).getActivityStreams(id, keys, keyByType, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the given route's streams. Requires read_all scope for private routes.
		 * @summary Get Route Streams
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteStreams(
			id: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
			const localVarFetchArgs = StreamsApiFetchParamCreator(
				configuration
			).getRouteStreams(id, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
		 * @summary Get Segment Effort Streams
		 * @param {number} id The identifier of the segment effort.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
			const localVarFetchArgs = StreamsApiFetchParamCreator(
				configuration
			).getSegmentEffortStreams(id, keys, keyByType, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns the given segment's streams. Requires read_all scope for private segments.
		 * @summary Get Segment Streams
		 * @param {number} id The identifier of the segment.
		 * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentStreams(
			id: number,
			keys: Array<'distance' | 'latlng' | 'altitude'>,
			keyByType: boolean,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
			const localVarFetchArgs = StreamsApiFetchParamCreator(
				configuration
			).getSegmentStreams(id, keys, keyByType, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
		 * @summary Get Activity Streams
		 * @param {number} id The identifier of the activity.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getActivityStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options?: unknown
		) {
			return StreamsApiFp(configuration).getActivityStreams(
				id,
				keys,
				keyByType,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the given route's streams. Requires read_all scope for private routes.
		 * @summary Get Route Streams
		 * @param {number} id The identifier of the route.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRouteStreams(id: number, options?: unknown) {
			return StreamsApiFp(configuration).getRouteStreams(id, options)(
				fetch,
				basePath
			);
		},
		/**
		 * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
		 * @summary Get Segment Effort Streams
		 * @param {number} id The identifier of the segment effort.
		 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentEffortStreams(
			id: number,
			keys: Array<
				| 'time'
				| 'distance'
				| 'latlng'
				| 'altitude'
				| 'velocity_smooth'
				| 'heartrate'
				| 'cadence'
				| 'watts'
				| 'temp'
				| 'moving'
				| 'grade_smooth'
			>,
			keyByType: boolean,
			options?: unknown
		) {
			return StreamsApiFp(configuration).getSegmentEffortStreams(
				id,
				keys,
				keyByType,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns the given segment's streams. Requires read_all scope for private segments.
		 * @summary Get Segment Streams
		 * @param {number} id The identifier of the segment.
		 * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
		 * @param {boolean} keyByType Must be true.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSegmentStreams(
			id: number,
			keys: Array<'distance' | 'latlng' | 'altitude'>,
			keyByType: boolean,
			options?: unknown
		) {
			return StreamsApiFp(configuration).getSegmentStreams(
				id,
				keys,
				keyByType,
				options
			)(fetch, basePath);
		}
	};
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
	/**
	 * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
	 * @summary Get Activity Streams
	 * @param {number} id The identifier of the activity.
	 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
	 * @param {boolean} keyByType Must be true.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StreamsApi
	 */
	public getActivityStreams(
		id: number,
		keys: Array<
			| 'time'
			| 'distance'
			| 'latlng'
			| 'altitude'
			| 'velocity_smooth'
			| 'heartrate'
			| 'cadence'
			| 'watts'
			| 'temp'
			| 'moving'
			| 'grade_smooth'
		>,
		keyByType: boolean,
		options?: unknown
	) {
		return StreamsApiFp(this.configuration).getActivityStreams(
			id,
			keys,
			keyByType,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the given route's streams. Requires read_all scope for private routes.
	 * @summary Get Route Streams
	 * @param {number} id The identifier of the route.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StreamsApi
	 */
	public getRouteStreams(id: number, options?: unknown) {
		return StreamsApiFp(this.configuration).getRouteStreams(id, options)(
			this.fetch,
			this.basePath
		);
	}

	/**
	 * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
	 * @summary Get Segment Effort Streams
	 * @param {number} id The identifier of the segment effort.
	 * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
	 * @param {boolean} keyByType Must be true.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StreamsApi
	 */
	public getSegmentEffortStreams(
		id: number,
		keys: Array<
			| 'time'
			| 'distance'
			| 'latlng'
			| 'altitude'
			| 'velocity_smooth'
			| 'heartrate'
			| 'cadence'
			| 'watts'
			| 'temp'
			| 'moving'
			| 'grade_smooth'
		>,
		keyByType: boolean,
		options?: unknown
	) {
		return StreamsApiFp(this.configuration).getSegmentEffortStreams(
			id,
			keys,
			keyByType,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns the given segment's streams. Requires read_all scope for private segments.
	 * @summary Get Segment Streams
	 * @param {number} id The identifier of the segment.
	 * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
	 * @param {boolean} keyByType Must be true.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StreamsApi
	 */
	public getSegmentStreams(
		id: number,
		keys: Array<'distance' | 'latlng' | 'altitude'>,
		keyByType: boolean,
		options?: unknown
	) {
		return StreamsApiFp(this.configuration).getSegmentStreams(
			id,
			keys,
			keyByType,
			options
		)(this.fetch, this.basePath);
	}
}

/**
 * UploadsApi - fetch parameter creator
 * @export
 */
export const UploadsApiFetchParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Uploads a new data file to create an activity from. Requires activity:write scope.
		 * @summary Upload Activity
		 * @param {unknown} [file] The uploaded file.
		 * @param {string} [name] The desired name of the resulting activity.
		 * @param {string} [description] The desired description of the resulting activity.
		 * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
		 * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
		 * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [dataType] The format of the uploaded file.
		 * @param {string} [externalId] The desired external identifier of the resulting activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUpload(
			file?: unknown,
			name?: string,
			description?: string,
			trainer?: string,
			commute?: string,
			dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
			externalId?: string,
			options: unknown = {}
		): FetchArgs {
			const localVarPath = `/uploads`;
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;
			const localVarFormParams = new url.URLSearchParams();

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			if (file !== undefined) {
				localVarFormParams.set('file', file as unknown);
			}

			if (name !== undefined) {
				localVarFormParams.set('name', name as unknown);
			}

			if (description !== undefined) {
				localVarFormParams.set('description', description as unknown);
			}

			if (trainer !== undefined) {
				localVarFormParams.set('trainer', trainer as unknown);
			}

			if (commute !== undefined) {
				localVarFormParams.set('commute', commute as unknown);
			}

			if (dataType !== undefined) {
				localVarFormParams.set('data_type', dataType as unknown);
			}

			if (externalId !== undefined) {
				localVarFormParams.set('external_id', externalId as unknown);
			}

			localVarHeaderParameter['Content-Type'] =
				'application/x-www-form-urlencoded';

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);
			localVarRequestOptions.body = localVarFormParams.toString();

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 * Returns an upload for a given identifier. Requires activity:write scope.
		 * @summary Get Upload
		 * @param {number} uploadId The identifier of the upload.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUploadById(uploadId: number, options: unknown = {}): FetchArgs {
			// verify required parameter 'uploadId' is not null or undefined
			if (uploadId === null || uploadId === undefined) {
				throw new RequiredError(
					'uploadId',
					'Required parameter uploadId was null or undefined when calling getUploadById.'
				);
			}
			const localVarPath = `/uploads/{uploadId}`.replace(
				`{${'uploadId'}}`,
				encodeURIComponent(String(uploadId))
			);
			const localVarUrlObj = url.parse(localVarPath, true);
			const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter = {} as unknown;
			const localVarQueryParameter = {} as unknown;

			// authentication strava_oauth required
			// oauth required
			if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue =
					typeof configuration.accessToken === 'function'
						? configuration.accessToken('strava_oauth', [])
						: configuration.accessToken;
				localVarHeaderParameter['Authorization'] =
					'Bearer ' + localVarAccessTokenValue;
			}

			localVarUrlObj.query = Object.assign(
				{},
				localVarUrlObj.query,
				localVarQueryParameter,
				options.query
			);
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search;
			localVarRequestOptions.headers = Object.assign(
				{},
				localVarHeaderParameter,
				options.headers
			);

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 * Uploads a new data file to create an activity from. Requires activity:write scope.
		 * @summary Upload Activity
		 * @param {unknown} [file] The uploaded file.
		 * @param {string} [name] The desired name of the resulting activity.
		 * @param {string} [description] The desired description of the resulting activity.
		 * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
		 * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
		 * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [dataType] The format of the uploaded file.
		 * @param {string} [externalId] The desired external identifier of the resulting activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUpload(
			file?: unknown,
			name?: string,
			description?: string,
			trainer?: string,
			commute?: string,
			dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
			externalId?: string,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
			const localVarFetchArgs = UploadsApiFetchParamCreator(
				configuration
			).createUpload(
				file,
				name,
				description,
				trainer,
				commute,
				dataType,
				externalId,
				options
			);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * Returns an upload for a given identifier. Requires activity:write scope.
		 * @summary Get Upload
		 * @param {number} uploadId The identifier of the upload.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUploadById(
			uploadId: number,
			options?: unknown
		): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
			const localVarFetchArgs = UploadsApiFetchParamCreator(
				configuration
			).getUploadById(uploadId, options);
			return (
				fetch: FetchAPI = portableFetch,
				basePath: string = BASE_PATH
			) => {
				return fetch(
					basePath + localVarFetchArgs.url,
					localVarFetchArgs.options
				).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		}
	};
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (
	configuration?: Configuration,
	fetch?: FetchAPI,
	basePath?: string
) {
	return {
		/**
		 * Uploads a new data file to create an activity from. Requires activity:write scope.
		 * @summary Upload Activity
		 * @param {unknown} [file] The uploaded file.
		 * @param {string} [name] The desired name of the resulting activity.
		 * @param {string} [description] The desired description of the resulting activity.
		 * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
		 * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
		 * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [dataType] The format of the uploaded file.
		 * @param {string} [externalId] The desired external identifier of the resulting activity.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUpload(
			file?: unknown,
			name?: string,
			description?: string,
			trainer?: string,
			commute?: string,
			dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
			externalId?: string,
			options?: unknown
		) {
			return UploadsApiFp(configuration).createUpload(
				file,
				name,
				description,
				trainer,
				commute,
				dataType,
				externalId,
				options
			)(fetch, basePath);
		},
		/**
		 * Returns an upload for a given identifier. Requires activity:write scope.
		 * @summary Get Upload
		 * @param {number} uploadId The identifier of the upload.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUploadById(uploadId: number, options?: unknown) {
			return UploadsApiFp(configuration).getUploadById(uploadId, options)(
				fetch,
				basePath
			);
		}
	};
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
	/**
	 * Uploads a new data file to create an activity from. Requires activity:write scope.
	 * @summary Upload Activity
	 * @param {unknown} [file] The uploaded file.
	 * @param {string} [name] The desired name of the resulting activity.
	 * @param {string} [description] The desired description of the resulting activity.
	 * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
	 * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
	 * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [dataType] The format of the uploaded file.
	 * @param {string} [externalId] The desired external identifier of the resulting activity.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UploadsApi
	 */
	public createUpload(
		file?: unknown,
		name?: string,
		description?: string,
		trainer?: string,
		commute?: string,
		dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
		externalId?: string,
		options?: unknown
	) {
		return UploadsApiFp(this.configuration).createUpload(
			file,
			name,
			description,
			trainer,
			commute,
			dataType,
			externalId,
			options
		)(this.fetch, this.basePath);
	}

	/**
	 * Returns an upload for a given identifier. Requires activity:write scope.
	 * @summary Get Upload
	 * @param {number} uploadId The identifier of the upload.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UploadsApi
	 */
	public getUploadById(uploadId: number, options?: unknown) {
		return UploadsApiFp(this.configuration).getUploadById(uploadId, options)(
			this.fetch,
			this.basePath
		);
	}
}
